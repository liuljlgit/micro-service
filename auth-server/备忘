阮一峰讲解oauth2地址:http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html

oauth2原理:
1.oauth2客户端授权有四种模型（几种模式其实最终都是向授权服务器获取可访问资源服务器的令牌）
  1.1）授权码模式(authorization code)
       例子：有一个"云冲印"的网站，可以将用户储存在Google的照片，冲印出来
       步骤：a)用户访问"云冲刷"网站,讲用户导向Google认证服务器
            b)用户选择在Google认证页面选择是否给予"云冲刷"授权
            c)如果用户给予授权：认证服务器将用户导向客户端事先指定的"重定向URI"，同时附上授权码，“云冲刷”收到授权码，再附上“重定向URI”,向服务器申请令牌。这写步骤在后台服务器完成对用户不可见。
                              简单来说：用户选择授权后，经过两次交互，“云冲刷”网站申请到了进入“Google”服务器获取图片资源的令牌：访问令牌（access_token）和更新令牌（refresh_token）
       简单的说：“云冲刷”这个客户端想拿到“Google”中的图片资源，那么“Google”认证服务器就让用户给这个客户端授权，如果给了那么我就发放一些令牌给这个客户端,这个客户端通过这个令牌就能访问我的资源。

  1.2）简化模式(implicit)
       步骤：a)客户端将用户导向认证服务器
            b)用户决定是否给于客户端授权
            c)假设用户给予授权，认证服务器将用户导向客户端指定的"重定向URI"，并在URI的Hash部分包含了访问令牌
            d)浏览器向资源服务器发出请求，其中不包括上一步收到的Hash值
            e)资源服务器返回一个网页，其中包含的代码可以获取Hash值中的令牌
            f)浏览器执行上一步获得的脚本，提取出令牌
            g)浏览器将令牌发给客户端
       授权码模式和简化模式的区别？
            简化模式不通过第三方应用程序的服务器，直接在浏览器中向认证服务器申请令牌，跳过了"授权码"这个步骤，因此得名。所有步骤在浏览器中完成，令牌对访问者是可见的，且客户端不需要认证。
       简单的说：
            简化模式就是用户选择给客户端授权后直接就返回Hash值（令牌包含在其中）。然后再访问资源服务器获取一些script脚本,执行脚本就可以解析出令牌。

  1.3）密码模式(resource owner password credentials)
        用户向客户端提供自己的用户名和密码。客户端使用这些信息，向"服务商提供商"索要授权。在这种模式中，用户必须把自己的密码给客户端，但是客户端不得储存密码。
        这通常用在用户对客户端高度信任的情况下，比如客户端是操作系统的一部分，或者由一个著名公司出品。而认证服务器只有在其他授权模式无法执行的情况下，才能考虑使用这种模式。
        （这种模式除非都是自己的系统，否则正常人为啥要把自己在“Google”的用户名密码提供给第三方？）
        步骤：a)用户向客户端提供用户名和密码
             b)客户端将用户名和密码发给认证服务器，向后者请求令牌
             c）认证服务器确认无误后，向客户端提供访问令牌
        简单的说：就是用户对“云冲刷”说，我把我的Google账号密码给你，你去把资源给我拿回来。

  1.4）客户端模式(client credentials)
       客户端模式指客户端以自己的名义，而不是以用户的名义，向"服务提供商"进行认证。严格地说，客户端模式并不属于OAuth框架所要解决的问题。在这种模式中，用户直接向客户端注册，客户端以自己的名义要求"服务提供商"提供服务，其实不存在授权问题。
       步骤：a)客户端向认证服务器进行身份认证，并要求一个访问令牌
            b)认证服务器确认无误后，向客户端提供访问令牌
       这种模式解决需解决：认证服务器必须以某种方式，验证客户端身份
       可能的一种方法：认证服务器记录可以访问的客户端ID?

2.更新令牌作用
  如果用户访问的时候，客户端的"访问令牌"已经过期，则需要使用"更新令牌"申请一个新的访问令牌


springcloud oauth2实现：
1.使用@EnableResourceServer声明一个资源服务器
2.使用@EnableAuthorizationServer声明一个认证服务器
  注意:资源服务器和认证服务器可在同一个项目中
3.如何通过JDK生成JKS证书？（作用:可以用来生成jwtAccessTokenConverter）
    keytool -genkeypair -alias oauth2jks -keyalg RSA -keypass 123456 -keystore keystore.jks -storepass 123456
    名字和姓氏:liulijun
    单位名称:huidian
    组织名称:huidian
    城市:guangzhou
    省/市/自治区:guangdong
    地区代码:GD
  生成证书后:可放置在项目的resource目录下
4.oauth2包中拥有一些UserDetailsService接口需要我们实现,通过实现这个接口获取用户的账号密码和权限信息
5.咱们springcloud架构单点认证，我们在auth-server中进行认证和授权得到令牌后再去访问其他的微服务，应该是在网关层进行代理验证是否进行登录和是否有相应的微服务权限
6.我们为什么要设置clientId和resourceId?
    我们可以为每一个Resource Server（一个微服务实例）设置一个resourceid。再给client授权的时候，可以设置这个client可以访问哪一些微服务实例，如果没设置，就是对所有的resource都有访问权限。
7.Oauth2和JWT的定义
    Oauth2是一种授权架构,提供了一套详细的授权机制。Oauth2的最终目的其实就是拿到一个accessToken令牌。而JWT是一种认证协议,其实就是用来生成token的。
    JWT是一种安全标准。基本思路就是用户提供用户名和密码给认证服务器，服务器验证用户提交信息信息的合法性；如果验证成功，会产生并返回一个Token（令牌），用户可以使用这个token访问服务器上受保护的资源。
        一个token的例子:eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9.TJVA95OrM7E2cBab30RMHrHDcEfxjoYZgeFONFh7HgQ
        token包含三部分:header.claims.signature
        Header头部分: 头部分简单声明了类型(JWT)以及产生签名所使用的算法.
            {
              "alg" : "AES256",
              "typ" : "JWT"
            }
        Claims声明:其实就是token中存放我们需要存放自定义信息,服务器拿到这个Token之后可以再进行解析这些信息。
        Signature签名: 签名的目的是为了保证上边两部分信息不被篡改。如果尝试使用Bas64对解码后的token进行修改，签名信息就会失效,其实就是用来加密的。就是咱们生成的那个jks文件。
8.springcloud的认证流程
    我估计是通过用户名密码验证后,通过JWT协议生成Token（我们会在这个Token的Claims声明部分加入用户名、用户授权信息）,服务器把这个Token保存到数据库或者redis（有期限）,同时返回token给用户。
    用户下次仿真的时候带上access_token,我们验证access_token在我们的数据库或者redis中是否存在,存在则证明已登录。这时可解析Token拿到用户名和用户授权等其他信息。


